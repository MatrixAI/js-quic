use std::*;
use std::net::*;

const MAX_DATAGRAM_SIZE: usize = 1350;

// FIXME: this is a temp test file, need to remove before merging

/// Generate a stateless retry token.
///
/// The token includes the static string `"quiche"` followed by the IP address
/// of the client and by the original destination connection ID generated by the
/// client.
///
/// Note that this function is only an example and doesn't do any cryptographic
/// authenticate of the token. *It should not be used in production system*.
fn mint_token(hdr: &quiche::Header, src: &net::SocketAddr) -> Vec<u8> {
  let mut token = Vec::new();

  token.extend_from_slice(b"quiche");

  let addr = match src.ip() {
    std::net::IpAddr::V4(a) => a.octets().to_vec(),
    std::net::IpAddr::V6(a) => a.octets().to_vec(),
  };

  token.extend_from_slice(&addr);
  token.extend_from_slice(&hdr.dcid);

  token
}

fn main() {

  const LOOPS: i32 = 200_000;
  let mut buf = [0; 65535];
  let mut out = [0; MAX_DATAGRAM_SIZE];

  // Create the configuration for the QUIC connection.
  let mut client_config = quiche::Config::new(quiche::PROTOCOL_VERSION).unwrap();

  // *CAUTION*: this should not be set to `false` in production!!!
  client_config.verify_peer(false);

  client_config
    .set_application_protos(&[
      b"hq-interop",
      b"hq-29",
      b"hq-28",
      b"hq-27",
      b"http/0.9",
    ])
    .unwrap();

  client_config.set_max_idle_timeout(5000);
  client_config.set_max_recv_udp_payload_size(MAX_DATAGRAM_SIZE);
  client_config.set_max_send_udp_payload_size(MAX_DATAGRAM_SIZE);
  client_config.set_initial_max_data(10_000_000);
  client_config.set_initial_max_stream_data_bidi_local(1_000_000);
  client_config.set_initial_max_stream_data_bidi_remote(1_000_000);
  client_config.set_initial_max_streams_bidi(100);
  client_config.set_initial_max_streams_uni(100);
  client_config.set_disable_active_migration(true);

  // server config
  // Create the configuration for the QUIC connections.
  let mut server_config = quiche::Config::new(quiche::PROTOCOL_VERSION).unwrap();

  server_config
    .load_cert_chain_from_pem_file("./examples/cert.crt")
    .unwrap();
  server_config
    .load_priv_key_from_pem_file("./examples/cert.key")
    .unwrap();

  server_config
    .set_application_protos(&[
      b"hq-interop",
      b"hq-29",
      b"hq-28",
      b"hq-27",
      b"http/0.9",
    ])
    .unwrap();

  server_config.set_max_idle_timeout(5000);
  server_config.set_max_recv_udp_payload_size(MAX_DATAGRAM_SIZE);
  server_config.set_max_send_udp_payload_size(MAX_DATAGRAM_SIZE);
  server_config.set_initial_max_data(10_000_000);
  server_config.set_initial_max_stream_data_bidi_local(1_000_000);
  server_config.set_initial_max_stream_data_bidi_remote(1_000_000);
  server_config.set_initial_max_stream_data_uni(1_000_000);
  server_config.set_initial_max_streams_bidi(100);
  server_config.set_initial_max_streams_uni(100);
  server_config.set_disable_active_migration(true);
  server_config.enable_early_data();



  // Generate a random source connection ID for the connection.
  let scid = [1; quiche::MAX_CONN_ID_LEN];
  let scid = quiche::ConnectionId::from_ref(&scid);

  // Get local address.
  let client_addr = net::SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 55555);
  let server_addr = net::SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 55556);

  let forward_info = quiche::RecvInfo {
    from: client_addr,
    to: server_addr,
  };
  let reverse_info = quiche::RecvInfo {
    from: server_addr,
    to: client_addr,
  };

  // Create a QUIC connection and initiate handshake.
  let mut client_conn =
    quiche::connect(None, &scid, client_addr, server_addr, &mut client_config)
      .unwrap();

  let (write, send_info) = client_conn.send(&mut out).expect("initial send failed");

  // Parse the QUIC packet's header.
  let hdr = match quiche::Header::from_slice(
    &mut out[..write],
    quiche::MAX_CONN_ID_LEN,
  ) {
    Ok(v) => v,

    Err(e) => {
      panic!("Parsing packet header failed: {:?}", e);
    },
  };


  let server_conn_id = [0; quiche::MAX_CONN_ID_LEN];

  let mut scid: [u8; quiche::MAX_CONN_ID_LEN] = [0; quiche::MAX_CONN_ID_LEN];
  scid.copy_from_slice(&server_conn_id);
  let scid = quiche::ConnectionId::from_ref(&scid);

  // Do stateless retry if the client didn't send a token.
  let new_token = mint_token(&hdr, &send_info.from);

  let len = quiche::retry(
    &hdr.scid,
    &hdr.dcid,
    &scid,
    &new_token,
    hdr.version,
    &mut out,
  )
    .unwrap();

  client_conn.recv(&mut out[..len], reverse_info).expect("something");
  let (write, _send_info) = client_conn.send(&mut out).expect("initial send failed");

  let mut server_conn = quiche::accept(
    &scid,
    Some(&hdr.dcid),
    server_addr,
    client_addr,
    &mut server_config,
  )
    .unwrap();

  let _read = match server_conn.recv(&mut out[..write], forward_info) {
    Ok(v) => v,

    Err(e) => {
      panic!("{} recv failed: {:?}", server_conn.trace_id(), e);
    },
  };

  // Client <-initial- server
  let (write, _send_info) = server_conn.send(&mut out).expect("initial send failed");
  let _read = match client_conn.recv(&mut out[..write], reverse_info) {
    Ok(v) => v,
    Err(e) => {
      panic!("{} recv failed: {:?}", client_conn.trace_id(), e);
    },
  };

  // Client -initial-> server
  let (write, _send_info) = client_conn.send(&mut out).expect("initial send failed");
  let _read = match server_conn.recv(&mut out[..write], forward_info) {
    Ok(v) => v,
    Err(e) => {
      panic!("{} recv failed: {:?}", server_conn.trace_id(), e);
    },
  };

  // Client <-handshake- server
  let (write, _send_info) = server_conn.send(&mut out).expect("initial send failed");
  let _read = match client_conn.recv(&mut out[..write], reverse_info) {
    Ok(v) => v,
    Err(e) => {
      panic!("{} recv failed: {:?}", client_conn.trace_id(), e);
    },
  };

  // Client -handshake-> server
  let (write, _send_info) = client_conn.send(&mut out).expect("initial send failed");
  let _read = match server_conn.recv(&mut out[..write], forward_info) {
    Ok(v) => v,
    Err(e) => {
      panic!("{} recv failed: {:?}", server_conn.trace_id(), e);
    },
  };

  // Client <-short- server
  let (write, _send_info) = server_conn.send(&mut out).expect("initial send failed");
  let _read = match client_conn.recv(&mut out[..write], reverse_info) {
    Ok(v) => v,
    Err(e) => {
      panic!("{} recv failed: {:?}", client_conn.trace_id(), e);
    },
  };

  // Client -short-> server
  let (write, _send_info) = client_conn.send(&mut out).expect("initial send failed");
  let _read = match server_conn.recv(&mut out[..write], forward_info) {
    Ok(v) => v,
    Err(e) => {
      panic!("{} recv failed: {:?}", server_conn.trace_id(), e);
    },
  };
  // Both are established

  // main loop
  let message = [0; 1024];
  // let before = time::Instant::now();
  // let mut send_time= 0;
  // let mut client_send_time= 0;
  // let mut server_recv_time= 0;
  // let mut stream_time= 0;
  // let mut server_send_time= 0;
  // let mut client_recv_time= 0;
  for _n in 1..LOOPS {
    // send data
    // let now = time::Instant::now();
    client_conn.stream_send(0, &message, false).expect("Stream send failed");
    // send_time += now.elapsed().as_nanos();
    // sending forward packets
    loop {
      // let now = time::Instant::now();
      let (write, _send_info) = match client_conn.send(&mut out){
        Ok(v) => v,
        Err(quiche::Error::Done) => {
          break;
        },
        Err(e) => {
          panic!("{} recv failed: {:?}", client_conn.trace_id(), e);
        },
      };
      // client_send_time += now.elapsed().as_nanos();
      // let now = time::Instant::now();
      let _read = match server_conn.recv(&mut out[..write], forward_info) {
        Ok(v) => v,
        Err(e) => {
          panic!("{} recv failed: {:?}", server_conn.trace_id(), e);
        },
      };
      // server_recv_time += now.elapsed().as_nanos();
    };
    // Processing streams
    // let now = time::Instant::now();
    for s in server_conn.readable() {
      while let Ok(..) =
        server_conn.stream_recv(s, &mut buf)
      {
        // Do nothing
      }
    }
    // stream_time += now.elapsed().as_nanos();
    // Processing reverse packets
    'reverse: loop {
      // let now = time::Instant::now();
      let (write, _send_info) = match server_conn.send(&mut out) {
        Ok(v) => v,
        Err(quiche::Error::Done) => {
          break 'reverse;
        },
        Err(e) => {
          panic!("{} recv failed: {:?}", server_conn.trace_id(), e);
        },
      };
      // server_send_time += now.elapsed().as_nanos();
      // let now = time::Instant::now();
      let _read = match client_conn.recv(&mut out[..write], reverse_info) {
        Ok(v) => v,
        Err(e) => {
          panic!("{} recv failed: {:?}", client_conn.trace_id(), e);
        },
      };
      // client_recv_time += now.elapsed().as_nanos();
    };
  }
  // let total_time = send_time + server_send_time + client_recv_time + stream_time + client_send_time + client_recv_time;
  // println!("total time elapsed {}ms", before.elapsed().as_millis());
  // println!("sum times {}ms", total_time / (1000*1000) );
  // println!("send time {}ms {}%", send_time / (1000*1000), send_time * 100 / total_time);
  // println!("server send time {}ms {}%", server_send_time / (1000*1000), server_send_time * 100 / total_time);
  // println!("client recv time {}ms {}%", client_recv_time / (1000*1000), client_recv_time * 100 / total_time);
  // println!("stream proc time {}ms {}%", stream_time / (1000*1000), stream_time * 100 / total_time);
  // println!("client send time {}ms {}%", client_send_time / (1000*1000), client_send_time * 100 / total_time);
  // println!("server recv time {}ms {}%", server_recv_time / (1000*1000), server_recv_time * 100 / total_time);
}
