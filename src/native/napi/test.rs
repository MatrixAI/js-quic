extern crate log;

// FIXME: this is a temp test file, need to remove before merging

#[cfg(test)]
mod tests {
  use std::*;
  use std::net::*;
  use ring::rand::*;

  const MAX_DATAGRAM_SIZE: usize = 1350;
  // const HTTP_REQ_STREAM_ID: u64 = 4;

  /// Generate a stateless retry token.
  ///
  /// The token includes the static string `"quiche"` followed by the IP address
  /// of the client and by the original destination connection ID generated by the
  /// client.
  ///
  /// Note that this function is only an example and doesn't do any cryptographic
  /// authenticate of the token. *It should not be used in production system*.
  fn mint_token(hdr: &quiche::Header, src: &net::SocketAddr) -> Vec<u8> {
    let mut token = Vec::new();

    token.extend_from_slice(b"quiche");

    let addr = match src.ip() {
      std::net::IpAddr::V4(a) => a.octets().to_vec(),
      std::net::IpAddr::V6(a) => a.octets().to_vec(),
    };

    token.extend_from_slice(&addr);
    token.extend_from_slice(&hdr.dcid);

    token
  }

  // /// Validates a stateless retry token.
  // ///
  // /// This checks that the ticket includes the `"quiche"` static string, and that
  // /// the client IP address matches the address stored in the ticket.
  // ///
  // /// Note that this function is only an example and doesn't do any cryptographic
  // /// authenticate of the token. *It should not be used in production system*.
  // fn validate_token<'a>(
  //   src: &net::SocketAddr, token: &'a [u8],
  // ) -> Option<quiche::ConnectionId<'a>> {
  //   if token.len() < 6 {
  //     return None;
  //   }
  //
  //   if &token[..6] != b"quiche" {
  //     return None;
  //   }
  //
  //   let token = &token[6..];
  //
  //   let addr = match src.ip() {
  //     std::net::IpAddr::V4(a) => a.octets().to_vec(),
  //     std::net::IpAddr::V6(a) => a.octets().to_vec(),
  //   };
  //
  //   if token.len() < addr.len() || &token[..addr.len()] != addr.as_slice() {
  //     return None;
  //   }
  //
  //   Some(quiche::ConnectionId::from_ref(&token[addr.len()..]))
  // }

  #[test]
  fn test_prof() {
    const LOOPS: i32 = 200_000;
    let mut buf = [0; 65535];
    let mut out = [0; MAX_DATAGRAM_SIZE];

    // Create the configuration for the QUIC connection.
    let mut client_config = quiche::Config::new(quiche::PROTOCOL_VERSION).unwrap();

    // *CAUTION*: this should not be set to `false` in production!!!
    client_config.verify_peer(false);

    client_config
      .set_application_protos(&[
        b"hq-interop",
        b"hq-29",
        b"hq-28",
        b"hq-27",
        b"http/0.9",
      ])
      .unwrap();

    client_config.set_max_idle_timeout(5000);
    client_config.set_max_recv_udp_payload_size(MAX_DATAGRAM_SIZE);
    client_config.set_max_send_udp_payload_size(MAX_DATAGRAM_SIZE);
    client_config.set_initial_max_data(10_000_000);
    client_config.set_initial_max_stream_data_bidi_local(1_000_000);
    client_config.set_initial_max_stream_data_bidi_remote(1_000_000);
    client_config.set_initial_max_streams_bidi(100);
    client_config.set_initial_max_streams_uni(100);
    client_config.set_disable_active_migration(true);

    // server config
    // Create the configuration for the QUIC connections.
    let mut server_config = quiche::Config::new(quiche::PROTOCOL_VERSION).unwrap();

    server_config
      .load_cert_chain_from_pem_file("./cert.crt")
      .unwrap();
    server_config
      .load_priv_key_from_pem_file("./cert.key")
      .unwrap();

    server_config
      .set_application_protos(&[
        b"hq-interop",
        b"hq-29",
        b"hq-28",
        b"hq-27",
        b"http/0.9",
      ])
      .unwrap();

    server_config.set_max_idle_timeout(5000);
    server_config.set_max_recv_udp_payload_size(MAX_DATAGRAM_SIZE);
    server_config.set_max_send_udp_payload_size(MAX_DATAGRAM_SIZE);
    server_config.set_initial_max_data(10_000_000);
    server_config.set_initial_max_stream_data_bidi_local(1_000_000);
    server_config.set_initial_max_stream_data_bidi_remote(1_000_000);
    server_config.set_initial_max_stream_data_uni(1_000_000);
    server_config.set_initial_max_streams_bidi(100);
    server_config.set_initial_max_streams_uni(100);
    server_config.set_disable_active_migration(true);
    server_config.enable_early_data();



    // Generate a random source connection ID for the connection.
    let mut scid = [0; quiche::MAX_CONN_ID_LEN];
    SystemRandom::new().fill(&mut scid[..]).unwrap();

    let scid = quiche::ConnectionId::from_ref(&scid);

    // Get local address.
    let client_addr = net::SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 55555);
    let server_addr = net::SocketAddr::new(IpAddr::V4(Ipv4Addr::new(127, 0, 0, 1)), 55556);

    let forward_info = quiche::RecvInfo {
      from: client_addr,
      to: server_addr,
    };
    let reverse_info = quiche::RecvInfo {
      from: server_addr,
      to: client_addr,
    };

    // Create a QUIC connection and initiate handshake.
    let mut client_conn =
      quiche::connect(None, &scid, client_addr, server_addr, &mut client_config)
        .unwrap();

    let (write, send_info) = client_conn.send(&mut out).expect("initial send failed");

    // Parse the QUIC packet's header.
    let hdr = match quiche::Header::from_slice(
      &mut out[..write],
      quiche::MAX_CONN_ID_LEN,
    ) {
      Ok(v) => v,

      Err(e) => {
        panic!("Parsing packet header failed: {:?}", e);
      },
    };

    let rng = SystemRandom::new();
    let conn_id_seed =
      ring::hmac::Key::generate(ring::hmac::HMAC_SHA256, &rng).unwrap();

    let server_conn_id = ring::hmac::sign(&conn_id_seed, &hdr.dcid);
    let server_conn_id = &server_conn_id.as_ref()[..quiche::MAX_CONN_ID_LEN];
    // let server_conn_id: [u8] = server_conn_id.to_vec().into();

    let mut scid: [u8; quiche::MAX_CONN_ID_LEN] = [0; quiche::MAX_CONN_ID_LEN];
    scid.copy_from_slice(&server_conn_id);
    let scid = quiche::ConnectionId::from_ref(&scid);

    // Do stateless retry if the client didn't send a token.
    let new_token = mint_token(&hdr, &send_info.from);

    let len = quiche::retry(
      &hdr.scid,
      &hdr.dcid,
      &scid,
      &new_token,
      hdr.version,
      &mut out,
    )
      .unwrap();

    client_conn.recv(&mut out[..len], reverse_info).expect("something");
    let (write, _send_info) = client_conn.send(&mut out).expect("initial send failed");

    let mut server_conn = quiche::accept(
      &scid,
      Some(&hdr.dcid),
      server_addr,
      client_addr,
      &mut server_config,
    )
      .unwrap();

    let _read = match server_conn.recv(&mut out[..write], forward_info) {
      Ok(v) => v,

      Err(e) => {
        panic!("{} recv failed: {:?}", server_conn.trace_id(), e);
      },
    };

    // Client <-initial- server
    let (write, _send_info) = server_conn.send(&mut out).expect("initial send failed");
    let _read = match client_conn.recv(&mut out[..write], reverse_info) {
      Ok(v) => v,
      Err(e) => {
        panic!("{} recv failed: {:?}", client_conn.trace_id(), e);
      },
    };

    // Client -initial-> server
    let (write, _send_info) = client_conn.send(&mut out).expect("initial send failed");
    let _read = match server_conn.recv(&mut out[..write], forward_info) {
      Ok(v) => v,
      Err(e) => {
        panic!("{} recv failed: {:?}", server_conn.trace_id(), e);
      },
    };

    // Client <-handshake- server
    let (write, _send_info) = server_conn.send(&mut out).expect("initial send failed");
    let _read = match client_conn.recv(&mut out[..write], reverse_info) {
      Ok(v) => v,
      Err(e) => {
        panic!("{} recv failed: {:?}", client_conn.trace_id(), e);
      },
    };

    // Client -handshake-> server
    let (write, _send_info) = client_conn.send(&mut out).expect("initial send failed");
    let _read = match server_conn.recv(&mut out[..write], forward_info) {
      Ok(v) => v,
      Err(e) => {
        panic!("{} recv failed: {:?}", server_conn.trace_id(), e);
      },
    };

    // Client <-short- server
    let (write, _send_info) = server_conn.send(&mut out).expect("initial send failed");
    let _read = match client_conn.recv(&mut out[..write], reverse_info) {
      Ok(v) => v,
      Err(e) => {
        panic!("{} recv failed: {:?}", client_conn.trace_id(), e);
      },
    };

    // Client -short-> server
    let (write, _send_info) = client_conn.send(&mut out).expect("initial send failed");
    let _read = match server_conn.recv(&mut out[..write], forward_info) {
      Ok(v) => v,
      Err(e) => {
        panic!("{} recv failed: {:?}", server_conn.trace_id(), e);
      },
    };
    // Both are established

    // main loop
    let message = [0; 1024];

    let before = time::Instant::now();
    for _n in 1..LOOPS {
      client_conn.stream_send(0, &message, false).expect("Stream send failed");
      // sending forward packets
      loop {
        let (write, _send_info) = match client_conn.send(&mut out){
          Ok(v) => v,
          Err(quiche::Error::Done) => {
            break;
          },
          Err(e) => {
            panic!("{} recv failed: {:?}", client_conn.trace_id(), e);
          },
        };
        let _read = match server_conn.recv(&mut out[..write], forward_info) {
          Ok(v) => v,
          Err(e) => {
            panic!("{} recv failed: {:?}", server_conn.trace_id(), e);
          },
        };
      };
      // Processing streams
      for s in server_conn.readable() {
        while let Ok(..) =
          server_conn.stream_recv(s, &mut buf)
        {
          // Do nothing
        }
      }
      // Processing reverse packets
      'reverse: loop {
        let (write, _send_info) = match server_conn.send(&mut out) {
          Ok(v) => v,
          Err(quiche::Error::Done) => {
            break 'reverse;
          },
          Err(e) => {
            panic!("{} recv failed: {:?}", server_conn.trace_id(), e);
          },
        };
        let _read = match client_conn.recv(&mut out[..write], reverse_info) {
          Ok(v) => v,
          Err(e) => {
            panic!("{} recv failed: {:?}", client_conn.trace_id(), e);
          },
        };
      };
    }
    println!("time elapsed {}", before.elapsed().as_millis());
  }
}

