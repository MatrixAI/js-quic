/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
/** Equivalent to quiche::CongestionControlAlgorithm */
export const enum CongestionControlAlgorithm {
  Reno = 0,
  CUBIC = 1,
  BBR = 2
}
/** Equivalent to quiche::Shutdown enum */
export const enum Shutdown {
  Read = 0,
  Write = 1
}
export interface Host {
  addr: string
  port: number
}
export interface SendInfo {
  /** The local address the packet should be sent from. */
  from: Host
  /** The remote address the packet should be sent to. */
  to: Host
  /** The time to send the packet out for pacing. */
  at: ExternalObject<Instant>
}
export interface RecvInfo {
  /** The remote address the packet was received from. */
  from: Host
  /** The local address the packet was sent to. */
  to: Host
}
/**
 * This maximum datagram size to SEND to the UDP socket
 * It must be used with `config.set_max_recv_udp_payload_size` and such
 * But on the receiving side, we actually use the maximum which is 65535
 */
export const MAX_DATAGRAM_SIZE: number
/**
 * This is the maximum size of the packet to be received from the socket
 * This is what you use to receive packets on the UDP socket
 * And you send it to the connection as well
 */
export const MAX_UDP_PACKET_SIZE: number
export const MAX_CONN_ID_LEN: number
export class Config {
  constructor()
  loadPrivKeyFromPemFile(file: string): void
  loadVerifyLocationsFromFile(file: string): void
  loadVerifyLocationsFromDirectory(dir: string): void
  verifyPeer(verify: boolean): void
  grease(grease: boolean): void
  logKeys(): void
  setTicketKey(key: Uint8Array): void
  enableEarlyData(): void
  setApplicationProtos(protosList: Array<string>): void
  setApplicationProtosWireFormat(protos: Uint8Array): void
  setMaxIdleTimeout(timeout: bigint): void
  setMaxRecvUdpPayloadSize(size: bigint): void
  setMaxSendUdpPayloadSize(size: bigint): void
  setInitialMaxData(v: bigint): void
  setInitialMaxStreamDataBidiLocal(v: bigint): void
  setInitialMaxStreamDataBidiRemote(v: bigint): void
  setInitialMaxStreamDataUni(v: bigint): void
  setInitialMaxStreamsBidi(v: bigint): void
  setInitialMaxStreamsUni(v: bigint): void
  setAckDelayExponent(v: bigint): void
  setMaxAckDelay(v: bigint): void
  setActiveConnectionIdLimit(v: bigint): void
  setDisableActiveMigration(v: boolean): void
  setCcAlgorithmName(name: string): void
  setCcAlgorithm(algo: CongestionControlAlgorithm): void
  enableHystart(v: boolean): void
  enablePacing(v: boolean): void
  enableDgram(enabled: boolean, recvQueueLen: bigint, sendQueueLen: bigint): void
  setMaxConnectionWindow(v: bigint): void
  setStatelessResetToken(v?: bigint | undefined | null): void
  setDisableDcidReuse(v: boolean): void
}
export class ConnectionId { }
export class Connection {
  /**
   * Creates QUIC Client Connection
   *
   * This can take both IP addresses and hostnames
   */
  static connect(scid: Uint8Array, localHost: Host, remoteHost: Host, config: Config): Connection
  static accept(scid: Uint8Array, localHost: Host, remoteHost: Host, config: Config): Connection
  setSession(session: Uint8Array): void
  recv(data: Uint8Array, recvInfo: RecvInfo): number
  /**
   * Sends a QUIC packet
   *
   * This writes to the data buffer passed in.
   * The buffer must be allocated to the size of MAX_DATAGRAM_SIZE.
   * This will return a JS array of `[length, send_info]`.
   * If the length is 0, then that there's no data to send.
   * The `send_info` will be set to `null`.
   */
  send(data: Uint8Array): [number, SendInfo | null]
  sendOnPath(data: Uint8Array, from?: Host | undefined | null, to?: Host | undefined | null): [number, SendInfo | null]
  sendQuantum(): number
  sendQuantumOnPath(localHost: Host, peerHost: Host): number
  streamRecv(streamId: number, data: Uint8Array): [number, boolean]
  streamSend(streamId: number, data: Uint8Array, fin: boolean): number
  streamPriority(streamId: number, urgency: number, incremental: boolean): void
  streamShutdown(streamId: number, direction: Shutdown, err: number): void
  streamCapacity(streamId: number): number
  streamReadable(streamId: number): boolean
  streamWritable(streamId: number, len: number): boolean
  streamFinished(streamId: number): boolean
  peerStreamsLeftBidi(): number
  peerStreamsLeftUni(): number
  readable(): StreamIter
  writable(): StreamIter
  maxSendUdpPayloadSize(): number
  dgramRecv(data: Uint8Array): number
  dgramRecvVec(): Uint8Array | null
  dgramRecvPeek(data: Uint8Array, len: number): number
  dgramRecvFrontLen(): number | null
  dgramRecvQueueLen(): number
  dgramRecvQueueByteSize(): number
  dgramSendQueueLen(): number
  dgramSendQueueByteSize(): number
  isDgramSendQueueFull(): boolean
  isDgramRecvQueueFull(): boolean
  dgramSend(data: Uint8Array): void
  dgramSendVec(data: Uint8Array): void
  dgramPurgeOutgoing(f: (arg0: Uint8Array) => boolean): void
  /**
   * Maximum dgram size
   *
   * Use this to determine the size of the dgrams being send and received
   * I'm not sure if this is also necessary for send and recv?
   */
  dgramMaxWritableLen(): number | null
  timeout(): number | null
  onTimeout(): void
  probePath(localHost: Host, peerHost: Host): number
  migrateSource(localHost: Host): number
  migrate(localHost: Host, peerHost: Host): number
  newSourceCid(scid: Uint8Array, resetToken: bigint, retireIfNeeded: boolean): number
  activeSourceCids(): number
  maxActiveSourceCids(): number
  sourceCidsLeft(): number
  retireDestinationCid(dcidSeq: number): void
  pathEventNext(): object
  retiredScidNext(): Uint8Array | null
  availableDcids(): number
  pathsIter(from: Host): HostIter
  close(app: boolean, err: number, reason: Uint8Array): void
  traceId(): string
  applicationProto(): Uint8Array
  serverName(): string | null
  peerCertChain(): Array<Uint8Array> | null
  session(): Uint8Array | null
  sourceId(): Uint8Array
  destinationId(): Uint8Array
  isEstablished(): boolean
  isResumed(): boolean
  isInEarlyData(): boolean
  isReadable(): boolean
  isPathValidated(from: Host, to: Host): boolean
  isDraining(): boolean
  isClosed(): boolean
  isTimedOut(): boolean
}
export class StreamIter {
  [Symbol.iterator](): Iterator<number, void, void>
}
export class HostIter {
  [Symbol.iterator](): Iterator<Host, void, void>
}
