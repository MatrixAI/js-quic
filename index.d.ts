/* tslint:disable */
/* eslint-disable */

/* auto-generated by NAPI-RS */

export class ExternalObject<T> {
  readonly '': {
    readonly '': unique symbol
    [K: symbol]: T
  }
}
/**
 * This maximum datagram size to SEND to the UDP socket
 * It must be used with `config.set_max_recv_udp_payload_size` and such
 * But on the receiving side, we actually use the maximum which is 65535
 */
export const MAX_DATAGRAM_SIZE: number
/**
 * This is the maximum size of the packet to be received from the socket
 * This is what you use to receive packets on the UDP socket
 * And you send it to the connection as well
 */
export const MAX_UDP_PACKET_SIZE: number
export const MAX_CONN_ID_LEN: number
export interface Host {
  ip: string
  port: number
}
export interface SendInfo {
  /** The local address the packet should be sent from. */
  from: Host
  /** The remote address the packet should be sent to. */
  to: Host
  /** The time to send the packet out for pacing. */
  at: ExternalObject<Instant>
}
export interface RecvInfo {
  /** The remote address the packet was received from. */
  from: Host
  /** The local address the packet was sent to. */
  to: Host
}
export class Config {
  constructor()
  verifyPeer(verify: boolean): void
  setMaxIdleTimeout(timeout: number): void
  setMaxRecvUdpPayloadSize(size: number): void
  setMaxSendUdpPayloadSize(size: number): void
}
export class Shutdown { }
/**
 * Creates random connection ID
 *
 * Relies on the JS runtime to provide the randomness system
 */
export class Connection {
  /**
   * Creates QUIC Client Connection
   *
   * This can take both IP addresses and hostnames
   */
  static connect(scid: Buffer, localHost: string, localPort: number, remoteHost: string, remotePort: number, config: Config): Connection
  static accept(scid: Buffer, localHost: string, localPort: number, remoteHost: string, remotePort: number, config: Config): Connection
  /**
   * Sends a QUIC packet
   *
   * This writes to the data buffer passed in.
   * The buffer must be allocated to the size of MAX_DATAGRAM_SIZE.
   * This will return a JS array of `[length, send_info]`.
   * If the length is 0, then that there's no data to send.
   * The `send_info` will be set to `null`.
   */
  send(data: Uint8Array): unknown[]
  recv(data: Uint8Array, recvInfo: RecvInfo): number
  /**
   * Maximum dgram size
   *
   * Use this to determine the size of the dgrams being send and received
   * I'm not sure if this is also necessary for send and recv?
   */
  dgramMaxWritableLen(): number | null
  dgramSend(data: Uint8Array): void
  dgramRecv(data: Uint8Array): number
  streamRecv(streamId: number, data: Uint8Array): unknown[]
  streamPriority(streamId: number, urgency: number, incremental: boolean): void
  streamSend(streamId: number, data: Uint8Array, fin: boolean): number
  streamShutdown(streamId: number, direction: Shutdown, err: number): void
  streamCapacity(streamId: number): number
  streamReadable(streamId: number): boolean
  streamWritable(streamId: number, len: number): boolean
  streamFinished(streamId: number): boolean
  peerStreamsLeftBidi(): number
  peerStreamsLeftUni(): number
}
